using System;
using System.IO;
using System.Runtime.InteropServices;

namespace SS14.Shared.Bsdiff
{
    /// <summary>
    ///     Implementation of bsdiff that returns and accepts bzip2 compressed diffs, size header included.
    /// </summary>
    public static class Bsdiff
    {
        [StructLayout(LayoutKind.Sequential)]
        internal unsafe struct DiffResult
        {
            public UInt64 length;
            public Byte* ptr;
        }

        [DllImport("bsdiffwrap.dll", EntryPoint = "bsdiff_bzip2_diff", CallingConvention = CallingConvention.Cdecl)]
        private static unsafe extern DiffResult Diff(Byte* old, UInt64 oldsize, Byte* newbuf, UInt64 newsize);

        [DllImport("bsdiffwrap.dll", EntryPoint = "bsdiff_bzip2_patch", CallingConvention = CallingConvention.Cdecl)]
        private static unsafe extern DiffResult Patch(Byte* old, UInt64 oldsize, Byte* patch, UInt64 patchsize);

        [DllImport("bsdiffwrap.dll", EntryPoint = "bsdiff_bzip2_cleanup", CallingConvention = CallingConvention.Cdecl)]
        private static unsafe extern void Cleanup(DiffResult toclean);

        /// <summary>
        ///     Generates a bzip2 compressed diff between an old and a new file. The size header is included.
        /// </summary>
        /// <param name="oldFile">The "old" file. This is the same "old" file as used by <see cref="ApplyBzip2Patch(byte[], byte[])"/>.</param>
        /// <param name="newFile">The "new" file that a diff will be made for.</param>
        /// <returns>A stream of bytes containing a bzip2 compressed diff accepted by <see cref="ApplyBzip2Patch(byte[], byte[])"/>.</returns>
        public static BsdiffStream GenerateBzip2Diff(byte[] oldFile, byte[] newFile)
        {
            unsafe
            {
                fixed (byte* oldPtr = oldFile)
                fixed (byte* newPtr = newFile)
                {
                    var result = Diff(oldPtr, (ulong)oldFile.Length, newPtr, (ulong)newFile.Length);
                    if (result.length > long.MaxValue)
                    {
                        Cleanup(result);
                        throw new InvalidOperationException("Diff result too large to handle.");
                    }
                    return new BsdiffStream(result);
                }
            }
        }

        /// <summary>
        ///     Applies a diff to a file, creating the "new" file used to make the diff originally.
        /// </summary>
        /// <param name="oldFile">The bytes of the original file.</param>
        /// <param name="patchFile">The "diff" file generated by <see cref="GenerateBzip2Diff(byte[], byte[])"/></param>
        /// <returns>The "new" file as a stream of bytes.</returns>
        public static BsdiffStream ApplyBzip2Patch(byte[] oldFile, byte[] patchFile)
        {
            unsafe
            {
                fixed (byte* oldPtr = oldFile)
                fixed (byte* patchPtr = patchFile)
                { 
                    var result = Patch(oldPtr, (ulong)oldFile.Length, patchPtr, (ulong)patchFile.Length);
                    if (result.length > long.MaxValue)
                    {
                        Cleanup(result);
                        throw new InvalidOperationException("Diff result too large to handle.");
                    }
                    return new BsdiffStream(result);
                }
            }
        }

        public class BsdiffStream : Stream
        {
            private UnmanagedMemoryStream UnmanagedStream;
            private readonly DiffResult Result;

            internal unsafe BsdiffStream(DiffResult result)
            {
                Result = result;
                UnmanagedStream = new UnmanagedMemoryStream(result.ptr, (long)result.length);
            }

            public byte[] ToArray()
            {
                var pos = Position;
                Position = 0;
                var array = new byte[Length];
                Read(array, 0, array.Length);
                Position = pos;
                return array;
            }

            public override bool CanRead => true;

            public override bool CanSeek => true;

            public override bool CanWrite => false;

            public override long Length => UnmanagedStream.Length;

            public override long Position
            {
                get => UnmanagedStream.Position;
                set => UnmanagedStream.Position = value;
            }

            public override void Flush() => UnmanagedStream.Flush();

            public override int Read(byte[] buffer, int offset, int count)
            {
                return UnmanagedStream.Read(buffer, offset, count);
            }

            public override long Seek(long offset, SeekOrigin origin)
            {
                return UnmanagedStream.Seek(offset, origin);
            }

            public override void SetLength(long value)
            {
                throw new NotSupportedException();
            }

            public override void Write(byte[] buffer, int offset, int count)
            {
                throw new NotSupportedException();
            }

            protected override void Dispose(bool disposing)
            {
                base.Dispose(disposing);

                if (disposing)
                {
                    UnmanagedStream.Dispose();
                }

                Cleanup(Result);
            }
        }
    }
}
